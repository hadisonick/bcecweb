import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useEffect, useState } from "react";
import { useDragLayer } from "react-dnd";
var layerStyles = {
  position: "fixed",
  pointerEvents: "none",
  zIndex: 100,
  left: 0,
  top: 0,
  width: "100%",
  height: "100%"
};
var subscribedToOffsetChange = false;
var dragPreviewRef = null;

var onOffsetChange = function onOffsetChange(monitor) {
  return function () {
    if (!dragPreviewRef) {
      return;
    }

    var offset = monitor.getClientOffset();

    if (!offset) {
      return;
    }

    var transform = "translate(".concat(offset.x - 15, "px, ").concat(offset.y - 15, "px)");
    dragPreviewRef.style["transform"] = transform;
    dragPreviewRef.style["-webkit-transform"] = transform;
  };
};

var DragPreview = function DragPreview() {
  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      dragHelperOpacity = _useState2[0],
      setDragHelperOpacity = _useState2[1];

  var _useDragLayer = useDragLayer(function (monitor) {
    if (!subscribedToOffsetChange) {
      // @ts-ignore
      monitor.subscribeToOffsetChange(onOffsetChange(monitor));
      subscribedToOffsetChange = true;
    }

    return {
      isDragging: monitor.isDragging(),
      item: monitor.getItem()
    };
  }),
      isDragging = _useDragLayer.isDragging,
      item = _useDragLayer.item;

  useEffect(function () {
    return function () {
      subscribedToOffsetChange = false;
      dragPreviewRef = null;
    };
  }, []); // We track the value of "isDragging" and apply opacity=1 (after 100ms), when it switches to true.
  // Without this, the drag cursor would be shown in the top-left corner for a short amount of time, and then it
  // would be repositioned correctly. Definitely looks like a glitch. This also adds a nice little fade-in effect.

  useEffect(function () {
    if (isDragging) {
      setTimeout(function () {
        setDragHelperOpacity(isDragging ? 1 : 0);
      }, 100);
    } else {
      setDragHelperOpacity(0);
    }
  }, [isDragging]);

  if (!isDragging) {
    return null;
  } // We don't want to show the drag preview for items being drag in the navigator.


  if (item && item.dragInNavigator) {
    return null;
  }

  return /*#__PURE__*/React.createElement("div", {
    style: layerStyles
  }, /*#__PURE__*/React.createElement("div", {
    ref: function ref(el) {
      return dragPreviewRef = el;
    },
    style: {
      display: "block",
      opacity: dragHelperOpacity,
      transition: "opacity .25s ease-in-out"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: 30,
      height: 30,
      backgroundColor: "var(--mdc-theme-primary)",
      borderRadius: "50%"
    }
  })));
};

export default DragPreview;
//# sourceMappingURL=DragPreview.js.map