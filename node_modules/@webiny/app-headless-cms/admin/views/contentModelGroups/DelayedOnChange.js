import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["children"];
import * as React from "react";
import noop from "lodash/noop";
/**
 * This component is used to wrap Input and Textarea components to optimize form re-render.
 * These 2 are the only components that trigger form model change on each character input.
 * This means, whenever you type a letter an entire form re-renders.
 * On complex forms you will feel and see a significant delay if this component is not used.
 *
 * The logic behind this component is to serve as a middleware between Form and Input/Textarea, and only notify form of a change when
 * a user stops typing for given period of time (400ms by default).
 */

var DelayedOnChange = /*#__PURE__*/function (_React$Component) {
  _inherits(DelayedOnChange, _React$Component);

  var _super = _createSuper(DelayedOnChange);

  function DelayedOnChange() {
    var _this;

    _classCallCheck(this, DelayedOnChange);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "delay", null);

    _defineProperty(_assertThisInitialized(_this), "state", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "applyValue", function (value) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      _this.delay && clearTimeout(_this.delay);
      _this.delay = null;

      _this.props.onChange(value, callback);
    });

    _defineProperty(_assertThisInitialized(_this), "onChange", function (value) {
      _this.setState({
        value: value
      }, _this.changed);
    });

    _defineProperty(_assertThisInitialized(_this), "changed", function () {
      _this.delay && clearTimeout(_this.delay);
      _this.delay = null;
      _this.delay = setTimeout(function () {
        return _this.applyValue(_this.state.value);
      }, _this.props.delay);
    });

    return _this;
  }

  _createClass(DelayedOnChange, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        value: this.props.value
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          children = _this$props.children,
          other = _objectWithoutProperties(_this$props, _excluded);

      var newProps = _objectSpread(_objectSpread({}, other), {}, {
        value: this.state.value,
        onChange: this.onChange
      });

      var renderProp = typeof children === "function" ? children : false;
      var child = renderProp ? renderProp(newProps) : /*#__PURE__*/React.cloneElement(children, newProps);

      var props = _objectSpread({}, child.props);

      var realOnKeyDown = props.onKeyDown || noop;
      var realOnBlur = props.onBlur || noop; // Need to apply value if input lost focus

      props.onBlur = function (e) {
        e.persist();

        _this2.applyValue(e.target.value, function () {
          return realOnBlur(e);
        });
      }; // Need to listen for TAB key to apply new value immediately, without delay. Otherwise validation will be triggered with old value.


      props.onKeyDown = function (e) {
        e.persist();

        if (e.key === "Tab") {
          _this2.applyValue(e.target.value, function () {
            return realOnKeyDown(e);
          });
        } else if (e.key === "Enter" && props["data-on-enter"]) {
          _this2.applyValue(e.target.value, function () {
            return realOnKeyDown(e);
          });
        } else {
          realOnKeyDown(e);
        }
      };

      return /*#__PURE__*/React.cloneElement(child, props);
    }
  }]);

  return DelayedOnChange;
}(React.Component);

_defineProperty(DelayedOnChange, "defaultProps", {
  delay: 400
});

export default DelayedOnChange;
//# sourceMappingURL=DelayedOnChange.js.map