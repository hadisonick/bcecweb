"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = _interopRequireDefault(require("util"));

var _ncp = _interopRequireDefault(require("ncp"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _case = _interopRequireDefault(require("case"));

var _replaceInPath = require("replace-in-path");

var _loadJsonFile = _interopRequireDefault(require("load-json-file"));

var _writeJsonFile = _interopRequireDefault(require("write-json-file"));

var _chalk = _interopRequireDefault(require("chalk"));

var _findUp = _interopRequireDefault(require("find-up"));

var _execa = _interopRequireDefault(require("execa"));

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _utils = require("@webiny/cli-plugin-scaffold/utils");

var _getContextMeta = _interopRequireDefault(require("./getContextMeta"));

const ncp = _util.default.promisify(_ncp.default.ncp);

const SCAFFOLD_DOCS_LINK = "https://www.webiny.com/docs/how-to-guides/scaffolding/extend-graphql-api";

var _default = () => ({
  name: "cli-plugin-scaffold-graphql",
  type: "cli-plugin-scaffold-template",
  scaffold: {
    name: "Extend GraphQL API",
    description: "Extends your GraphQL API with new CRUD query and mutation operations." + (_terminalLink.default.isSupported ? "\n  " + (0, _terminalLink.default)("Learn more.", SCAFFOLD_DOCS_LINK) : ""),
    questions: ({
      context
    }) => {
      return [{
        name: "pluginsFolderPath",
        message: "Enter plugins folder path:",
        default: () => {
          return context.localStorage.get(_utils.LAST_USED_GQL_API_PLUGINS_PATH) || `api/code/graphql/src/plugins`;
        },
        validate: pluginsFolderPath => {
          if (pluginsFolderPath.length < 2) {
            return `Please enter GraphQL API ${_chalk.default.cyan("plugins")} folder path.`;
          }

          return true;
        }
      }, {
        name: "dataModelName",
        message: "Enter initial entity name:",
        default: "Todo",
        validate: (dataModelName, answers) => {
          if (!dataModelName.match(/^([a-zA-Z]+)$/)) {
            return "A valid name must consist of letters only.";
          }

          const pluralizedCamelCasedDataModelName = (0, _pluralize.default)(_case.default.camel(dataModelName));

          const newCodePath = _path.default.resolve(_path.default.join(answers.pluginsFolderPath, "scaffolds", pluralizedCamelCasedDataModelName));

          if (_fs.default.existsSync(newCodePath)) {
            const relativePath = _path.default.relative(context.project.root, newCodePath);

            return `Cannot continue - the ${_chalk.default.red(relativePath)} folder already exists.`;
          }

          return true;
        }
      }];
    },
    generate: async ({
      input,
      ora,
      inquirer,
      wait,
      context
    }) => {
      var _packageJson$devDepen;

      context.localStorage.set(_utils.LAST_USED_GQL_API_PLUGINS_PATH, input.pluginsFolderPath); // Store used input, so that maybe some of

      const dataModelName = {
        plural: (0, _pluralize.default)(_case.default.camel(input.dataModelName)),
        singular: _pluralize.default.singular(_case.default.camel(input.dataModelName))
      };

      const scaffoldsPath = _path.default.join(input.pluginsFolderPath, "scaffolds");

      const scaffoldsIndexPath = _path.default.join(scaffoldsPath, "index.ts");

      const newCodePath = _path.default.join(scaffoldsPath, _case.default.camel(dataModelName.plural));

      const packageJsonPath = _path.default.relative(context.project.root, _findUp.default.sync("package.json", {
        cwd: input.pluginsFolderPath
      }));

      const templateFolderPath = _path.default.join(__dirname, "template"); // Get needed dependencies updates.


      const dependenciesUpdates = [];
      const packageJson = await (0, _loadJsonFile.default)(packageJsonPath);

      if (!(packageJson !== null && packageJson !== void 0 && (_packageJson$devDepen = packageJson.devDependencies) !== null && _packageJson$devDepen !== void 0 && _packageJson$devDepen["graphql-request"])) {
        dependenciesUpdates.push(["devDependencies", "graphql-request", "^3.4.0"]);
      }

      if (input.showConfirmation !== false) {
        console.log();
        console.log(`${_chalk.default.bold("The following operations will be performed on your behalf:")}`);
        console.log(`- new plugins will be created in ${_chalk.default.green(newCodePath)}`);
        console.log(`- created plugins will be imported in ${_chalk.default.green(scaffoldsIndexPath)}`);

        if (dependenciesUpdates.length) {
          console.log(`- dependencies in ${_chalk.default.green(packageJsonPath)} will be updated `);
        }

        const prompt = inquirer.createPromptModule();
        const {
          proceed
        } = await prompt({
          name: "proceed",
          message: `Are you sure you want to continue?`,
          type: "confirm",
          default: false
        });

        if (!proceed) {
          process.exit(0);
        }

        console.log();
      }

      ora.start(`Creating new plugins in ${_chalk.default.green(newCodePath)}...`);
      await wait(1000);

      _fs.default.mkdirSync(newCodePath, {
        recursive: true
      });

      await ncp(templateFolderPath, newCodePath); // Remove I18N and Security-related code if the GraphQL API doesn't support those.
      // Support is being detected via `Context` type, defined withing the root types.ts file.

      const typesTsPath = _findUp.default.sync("types.ts", {
        cwd: input.pluginsFolderPath
      });

      if (typesTsPath) {
        const meta = (0, _getContextMeta.default)(typesTsPath);

        if (!meta.i18n) {
          // If I18NContext was not detected, comment out relevant I18N code.
          const codeReplacements = [{
            find: `const locale = this\\.context\\.i18nContent`,
            replaceWith: `// const locale = this.context.i18nContent`
          }, {
            find: "base = `L#",
            replaceWith: "// base = `L#;"
          }];
          (0, _replaceInPath.replaceInPath)(_path.default.join(newCodePath, "/resolvers/TargetDataModelsResolver.ts"), codeReplacements);
        }

        if (!meta.security) {
          {
            // If I18NContext was not detected, comment out relevant I18N code.
            const codeReplacements = [{
              find: `import { SecurityIdentity } from`,
              replaceWith: `// import { SecurityIdentity } from`
            }, {
              find: "createdBy: Pick<SecurityIdentity",
              replaceWith: "// createdBy: Pick<SecurityIdentity"
            }];
            (0, _replaceInPath.replaceInPath)(_path.default.join(newCodePath, "/types.ts"), codeReplacements);
          }
          {
            // If I18NContext was not detected, comment out relevant I18N code.
            const codeReplacements = [{
              find: `const { security } = this.context;`,
              replaceWith: `// const { security } = this.context;`
            }, {
              find: "const identity = await security.getIdentity",
              replaceWith: "// const identity = await security.getIdentity"
            }, {
              find: new RegExp("createdBy: identity.*},", "gms"),
              replaceWith: "/* $& */"
            }];
            (0, _replaceInPath.replaceInPath)(_path.default.join(newCodePath, "/resolvers/TargetDataModelsMutation.ts"), codeReplacements);
          }
        }
      } // Replace generic "TargetDataModel" with received "dataModelName" argument.


      const codeReplacements = [{
        find: "targetDataModels",
        replaceWith: _case.default.camel(dataModelName.plural)
      }, {
        find: "TargetDataModels",
        replaceWith: _case.default.pascal(dataModelName.plural)
      }, {
        find: "TARGET_DATA_MODELS",
        replaceWith: _case.default.constant(dataModelName.plural)
      }, {
        find: "targetDataModel",
        replaceWith: _case.default.camel(dataModelName.singular)
      }, {
        find: "TargetDataModel",
        replaceWith: _case.default.pascal(dataModelName.singular)
      }, {
        find: "TARGET_DATA_MODEL",
        replaceWith: _case.default.constant(dataModelName.singular)
      }];
      (0, _replaceInPath.replaceInPath)(_path.default.join(newCodePath, "/**/*.ts"), codeReplacements);
      const fileNameReplacements = [{
        find: "__tests__/graphql/targetDataModels.ts",
        replaceWith: `__tests__/graphql/${dataModelName.plural}.ts`
      }, {
        find: "/entities/TargetDataModel.ts",
        replaceWith: `/entities/${_case.default.pascal(dataModelName.singular)}.ts`
      }, {
        find: "/resolvers/TargetDataModelsMutation.ts",
        replaceWith: `/resolvers/${_case.default.pascal(dataModelName.plural)}Mutation.ts`
      }, {
        find: "/resolvers/TargetDataModelsQuery.ts",
        replaceWith: `/resolvers/${_case.default.pascal(dataModelName.plural)}Query.ts`
      }, {
        find: "/resolvers/TargetDataModelsResolver.ts",
        replaceWith: `/resolvers/${_case.default.pascal(dataModelName.plural)}Resolver.ts`
      }];

      for (const fileNameReplacement of fileNameReplacements) {
        _fs.default.renameSync(_path.default.join(newCodePath, fileNameReplacement.find), _path.default.join(newCodePath, fileNameReplacement.replaceWith));
      }

      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `New plugins created in ${_chalk.default.green(newCodePath)}.`
      });
      ora.start(`Importing created plugins in ${_chalk.default.green(scaffoldsIndexPath)}.`);
      await wait(1000);
      (0, _utils.createScaffoldsIndexFile)(scaffoldsPath);
      await (0, _utils.updateScaffoldsIndexFile)({
        scaffoldsIndexPath,
        importName: dataModelName.plural,
        importPath: `./${dataModelName.plural}`
      });
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `Imported created plugins in ${_chalk.default.green(scaffoldsIndexPath)}.`
      });

      if (dependenciesUpdates.length) {
        ora.start(`Updating dependencies...`);
        dependenciesUpdates.forEach(([type, name, version]) => {
          if (!packageJson[type]) {
            packageJson[type] = {};
          }

          packageJson[type][name] = version;
        });
        await (0, _writeJsonFile.default)(packageJsonPath, packageJson);
        await (0, _execa.default)("yarn", [], {
          cwd: _path.default.dirname(packageJsonPath)
        });
        ora.stopAndPersist({
          symbol: _chalk.default.green("✔"),
          text: `Dependencies updated.`
        });
      }

      await (0, _utils.formatCode)("**/*.ts", {
        cwd: newCodePath
      });
      await (0, _utils.formatCode)("package.json", {
        cwd: _path.default.dirname(packageJsonPath)
      });
    },
    onSuccess: async () => {
      console.log();
      console.log(`${_chalk.default.green("✔")} New GraphQL API plugins created and imported successfully.`);
      console.log();
      console.log(_chalk.default.bold("Next Steps"));
      console.log(`‣ deploy the extended GraphQL API and continue developing by running the ${_chalk.default.green("yarn webiny watch api/code/graphql --env {dev}")} command`);
      console.log();
      console.log(_chalk.default.bold("Useful Links"));
      const links = [["Extend GraphQL API", SCAFFOLD_DOCS_LINK], ["Use the Watch Command", "https://www.webiny.com/docs/how-to-guides/use-watch-command"]];
      links.forEach(([text, url]) => console.log((0, _terminalLink.default)("‣ " + text, url, {
        fallback: (text, link) => text + " - " + link
      })));
    }
  }
});

exports.default = _default;
//# sourceMappingURL=index.js.map