{"version":3,"sources":["../src/validation.ts"],"names":["entries","validators","Object","invalidRules","createdValidators","async","sync","Validation","constructor","__validators","setValidator","name","callable","getValidator","ValidationError","validate","value","options","Error","parsedValidateProperty","__parseValidateProperty","params","validator","e","validationError","message","throw","validateSync","create","createSync","split","parsedValidators","forEach","v","vName","shift"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport ValidationError from \"./validationError\";\nimport { Validator, ValidateOptions, ParsedValidators } from \"./types\";\n\nconst entries = (validators: ParsedValidators): Array<[string, Array<string>]> => {\n    return Object.entries(validators);\n};\n\nconst invalidRules = \"Validators must be specified as a string (eg. required,minLength:10,email).\";\n\nconst createdValidators = {\n    async: {},\n    sync: {}\n};\n\n/**\n * Main class of Validation library.\n * Exported as a singleton instance, it offers methods for sync/async data validation and overwriting or adding new validators.\n *\n * @class Validation\n * @example\n * import { validation } from '@webiny/validation';\n *\n * // `validation` is a preconfigured instance of Validation class.\n * // From here you can either add new validators or use it as-is.\n */\nclass Validation {\n    /**\n     * Contains a list of all set validators.\n     * @private\n     */\n    __validators: { [key: string]: Validator };\n\n    constructor() {\n        this.__validators = {};\n    }\n\n    /**\n     * Add new validator.\n     * @param name Validator name.\n     * @param callable Validator function which throws a ValidationError if validation fails.\n     * @returns {Validation}\n     */\n    setValidator(name: string, callable: Validator): this {\n        this.__validators[name] = callable;\n        return this;\n    }\n\n    /**\n     * Get validator function by name.\n     * @param name Validator name.\n     * @returns {Validator} A validator function.\n     */\n    getValidator(name: string): Validator {\n        if (!this.__validators[name]) {\n            throw new ValidationError(\"Validator `\" + name + \"` does not exist!\", name);\n        }\n        return this.__validators[name];\n    }\n\n    /**\n     * Asynchronously validates value.\n     * @param value Value to validate.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @param [options] Validation options.\n     * @returns {Promise<boolean | ValidationError>}\n     */\n    async validate(\n        value: any,\n        validators: string,\n        options: ValidateOptions = {}\n    ): Promise<boolean | ValidationError> {\n        if (_.isString(validators) && _.isEmpty(validators)) {\n            return true;\n        }\n\n        if (!_.isString(validators)) {\n            throw new Error(invalidRules);\n        }\n\n        const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n        for (const [name, params] of entries(parsedValidateProperty)) {\n            const validator = this.getValidator(name);\n            try {\n                await validator(value, params);\n            } catch (e) {\n                const validationError = new ValidationError(e.message, name, value);\n                if (options.throw === false) {\n                    return validationError;\n                }\n                throw validationError;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Synchronously validates value.\n     * @param value Value to validate.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @param [options] Validation options.\n     * @returns {Promise<boolean | ValidationError>}\n     */\n    validateSync(\n        value: any,\n        validators: string,\n        options: ValidateOptions = {}\n    ): boolean | ValidationError {\n        if (_.isString(validators) && _.isEmpty(validators)) {\n            return true;\n        }\n\n        if (!_.isString(validators)) {\n            throw new Error(invalidRules);\n        }\n\n        const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n        for (const [name, params] of entries(parsedValidateProperty)) {\n            const validator = this.getValidator(name);\n            try {\n                validator(value, params);\n            } catch (e) {\n                const validationError = new ValidationError(e.message, name, value);\n                if (options.throw === false) {\n                    return validationError;\n                }\n                throw validationError;\n            }\n        }\n        return true;\n    }\n\n    create(validators: string) {\n        if (createdValidators.async[validators]) {\n            return createdValidators.async[validators];\n        }\n\n        createdValidators.async[validators] = value => this.validate(value, validators);\n        return createdValidators.async[validators];\n    }\n\n    createSync(validators: string) {\n        if (createdValidators.sync[validators]) {\n            return createdValidators.sync[validators];\n        }\n\n        createdValidators.sync[validators] = value => this.validateSync(value, validators);\n        return createdValidators.sync[validators];\n    }\n\n    /**\n     * Parses a string of validators with parameters.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @returns {ParsedValidators}\n     * @private\n     */\n    __parseValidateProperty(validators: string): ParsedValidators {\n        const validate: Array<string> = validators.split(\",\");\n\n        const parsedValidators: ParsedValidators = {};\n        validate.forEach((v: string) => {\n            const params = _.trim(v).split(\":\");\n            const vName = params.shift();\n            parsedValidators[vName] = params;\n        });\n        return parsedValidators;\n    }\n}\n\nexport default Validation;\n"],"file":"validation.js"}