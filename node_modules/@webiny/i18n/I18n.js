"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assign2 = _interopRequireDefault(require("lodash/assign"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _shortHash = _interopRequireDefault(require("short-hash"));

var fecha = _interopRequireWildcard(require("fecha"));

var _accounting = _interopRequireDefault(require("accounting"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Main class used for all I18n needs.
 */
class I18N {
  constructor() {
    (0, _defineProperty2.default)(this, "locale", void 0);
    (0, _defineProperty2.default)(this, "defaultFormats", void 0);
    (0, _defineProperty2.default)(this, "translations", void 0);
    (0, _defineProperty2.default)(this, "modifiers", void 0);
    (0, _defineProperty2.default)(this, "processors", void 0);
    this.locale = null;
    /**
     * If we fail to fetch formats for currently selected locale, these default formats will be used.
     * @type {{date: string, time: string, datetime: string, number: string}}
     */

    this.defaultFormats = this.getDefaultFormats();
    /**
     * All currently-loaded translations, for easier (synchronous) access.
     * @type {{}}
     */

    this.translations = {};
    /**
     * All registered modifiers.
     * @type {{}}
     */

    this.modifiers = {};
    /**
     * All registered processors.
     * Default built-in processors are registered immediately below.
     * @type {{}}
     */

    this.processors = {};
  }

  translate(base, namespace) {
    // Returns full translation for given base text in given namespace (optional).
    // If translation isn't found, base text will be returned.
    // We create a key out of given namespace and base text.
    if (!namespace) {
      throw Error("I18N text namespace not defined.");
    }

    base = (0, _get2.default)(base, "raw.0", base);
    let translation = this.getTranslation(namespace + "." + (0, _shortHash.default)(base));

    if (!translation) {
      translation = base;
    }

    const hasVariables = base.includes("{") && base.includes("}");

    if (hasVariables) {
      // @ts-ignore
      return values => {
        const data = {
          translation,
          base,
          namespace,
          values,
          i18n: this
        };

        for (const key in this.processors) {
          if (this.processors[key].canExecute(data)) {
            return this.processors[key].execute(data);
          }
        }

        return null;
      };
    }

    const data = {
      translation,
      base,
      namespace,
      values: {},
      i18n: this
    };

    for (const key in this.processors) {
      if (this.processors[key].canExecute(data)) {
        return this.processors[key].execute(data);
      }
    }

    return null;
  }

  namespace(namespace) {
    return base => {
      return this.translate(base, namespace);
    };
  }

  ns(namespace) {
    return this.namespace(namespace);
  }
  /**
   * Formats and outputs date.
   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.
   * @param value
   * @param outputFormat
   * @param inputFormat
   */


  date(value, outputFormat, inputFormat) {
    if (!outputFormat) {
      outputFormat = this.getDateFormat();
    }

    let parsedValue;

    if (typeof value === "string") {
      parsedValue = fecha.parse(value, inputFormat);
    }

    return fecha.format(parsedValue, outputFormat);
  }
  /**
   * Formats and outputs time.
   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.
   * @param value
   * @param outputFormat
   * @param inputFormat
   */


  time(value, outputFormat = null, inputFormat = "YYYY-MM-DDTHH:mm:ss.SSSZ") {
    if (!outputFormat) {
      outputFormat = this.getTimeFormat();
    }

    let parsedValue;

    if (typeof value === "string") {
      parsedValue = fecha.parse(value, inputFormat);
    }

    return fecha.format(parsedValue, outputFormat);
  }
  /**
   * Formats and outputs date/time.
   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.
   * @param value
   * @param outputFormat
   * @param inputFormat
   */


  dateTime(value, outputFormat = null, inputFormat = "YYYY-MM-DDTHH:mm:ss.SSSZ") {
    if (!outputFormat) {
      outputFormat = this.getDateTimeFormat();
    }

    let parsedValue;

    if (typeof value === "string") {
      parsedValue = fecha.parse(value, inputFormat);
    }

    return fecha.format(parsedValue, outputFormat);
  }
  /**
   * Outputs formatted number as amount of price.
   * @param value
   * @param outputFormat
   */


  price(value, outputFormat) {
    if (!outputFormat) {
      outputFormat = this.getPriceFormat();
    } else {
      outputFormat = (0, _assign2.default)({}, this.defaultFormats.price, outputFormat);
    } // Convert placeholders to accounting's placeholders.


    let format = outputFormat.format;
    format = format.replace("{symbol}", "%s");
    format = format.replace("{amount}", "%v");
    return _accounting.default.formatMoney(value, outputFormat.symbol, outputFormat.precision, outputFormat.thousand, outputFormat.decimal, format);
  }
  /**
   * Outputs formatted number.
   * @param value
   * @param outputFormat
   */


  number(value, outputFormat) {
    if (!outputFormat) {
      outputFormat = this.getNumberFormat();
    } else {
      outputFormat = (0, _assign2.default)({}, this.defaultFormats.number, outputFormat);
    }

    return _accounting.default.formatNumber(value, outputFormat.precision, outputFormat.thousand, outputFormat.decimal);
  }
  /**
   * Returns translation for given text key.
   * @param key
   * @returns {*|string}
   */


  getTranslation(key) {
    return this.translations[key];
  }
  /**
   * Returns all translations for current locale.
   * @returns {*|{}}
   */


  getTranslations() {
    return this.translations;
  }
  /**
   * Returns true if given key has a translation for currently set locale.
   * @param key
   */


  hasTranslation(key) {
    return key in this.translations;
  }
  /**
   * Sets translation for given text key.
   * @param key
   * @param translation
   * @returns {I18N}
   */


  setTranslation(key, translation) {
    this.translations[key] = translation;
    return this;
  }
  /**
   * Sets translations that will be used.
   * @returns {*|{}}
   */


  setTranslations(translations) {
    this.translations = translations;
    return this;
  }
  /**
   * Clears all translations.
   * @returns {*|{}}
   */


  clearTranslations() {
    this.setTranslations({});
    return this;
  }
  /**
   * Merges given translations object with already existing.
   * @returns {*|{}}
   */


  mergeTranslations(translations) {
    return (0, _assign2.default)(this.translations, translations);
  }
  /**
   * Returns currently selected locale (locale's key).
   */


  getLocale() {
    return this.locale;
  }
  /**
   * Sets current locale.
   */


  setLocale(locale) {
    this.locale = locale;
    return this;
  }
  /**
   * Registers single modifier.
   * @returns {I18N}
   */


  registerModifier(modifier) {
    this.modifiers[modifier.name] = modifier;
    return this;
  }
  /**
   * Registers all modifiers in given array.
   * @param modifiers
   * @returns {I18N}
   */


  registerModifiers(modifiers) {
    modifiers.forEach(modifier => this.registerModifier(modifier));
    return this;
  }
  /**
   * Unregisters given modifier.
   * @param name
   * @returns {I18N}
   */


  unregisterModifier(name) {
    delete this.modifiers[name];
    return this;
  }
  /**
   * Registers single processor.
   * @returns {I18N}
   */


  registerProcessor(processor) {
    this.processors[processor.name] = processor;
    return this;
  }
  /**
   * Registers all processors in given array.
   * @param processors
   * @returns {I18N}
   */


  registerProcessors(processors) {
    processors.forEach(processor => this.registerProcessor(processor));
    return this;
  }
  /**
   * Unregisters given processor.
   * @param name
   * @returns {I18N}
   */


  unregisterProcessor(name) {
    delete this.processors[name];
    return this;
  }
  /**
   * Returns default formats
   * @returns {{date: string, time: string, datetime: string, number: string}}
   */


  getDefaultFormats() {
    return {
      date: "DD/MM/YYYY",
      time: "HH:mm",
      datetime: "DD/MM/YYYY HH:mm",
      price: {
        symbol: "",
        format: "{symbol}{amount}",
        decimal: ".",
        thousand: ",",
        precision: 2
      },
      number: {
        decimal: ".",
        thousand: ",",
        precision: 2
      }
    };
  }
  /**
   * Returns current format to be used when outputting dates.
   */


  getDateFormat() {
    return (0, _get2.default)(this.locale, "formats.date", this.defaultFormats.date);
  }
  /**
   * Returns current format to be used when outputting time.
   */


  getTimeFormat() {
    return (0, _get2.default)(this.locale, "formats.time", this.defaultFormats.time);
  }
  /**
   * Returns current format to be used when outputting date/time.
   */


  getDateTimeFormat() {
    return (0, _get2.default)(this.locale, "formats.datetime", this.defaultFormats.datetime);
  }
  /**
   * Returns current format to be used when outputting prices.
   */


  getPriceFormat() {
    return (0, _assign2.default)({}, this.defaultFormats.price, (0, _get2.default)(this.locale, "formats.price", {}));
  }
  /**
   * Returns current format to be used when outputting numbers.
   */


  getNumberFormat() {
    return (0, _assign2.default)({}, this.defaultFormats.number, (0, _get2.default)(this.locale, "formats.number", {}));
  }

}

exports.default = I18N;
//# sourceMappingURL=I18n.js.map